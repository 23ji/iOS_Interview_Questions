#  19. ARC(Automatic Reference Counting)의 동작 원리는 무엇인가요?

## 한 줄 개념

ARC는 **객체가 언제 메모리에서 사라져야 하는지 자동으로 관리해주는 시스템**임

Swift에서는 개발자가 `free`, `delete` 같은 걸 직접 안 함
대신 **참조 개수(reference count)** 로 메모리를 관리함

---

## 1️⃣ ARC의 핵심 원리 (진짜 중요)

### ARC가 보는 건 딱 하나임

👉 **이 객체를 누가 쓰고 있냐?**

### 규칙

* 누군가 객체를 **참조하면** → reference count +1
* 참조를 **끊으면** → reference count -1
* reference count가 **0이 되는 순간** → 메모리에서 제거됨

이 과정이 **자동**이라서 Automatic Reference Counting임

---

## 2️⃣ 참조 카운트 흐름 예시

```swift
class Person {}

var a: Person? = Person() // count = 1
var b = a                // count = 2

a = nil                  // count = 1
b = nil                  // count = 0 → 메모리 해제
```

👉 아무도 안 쓰는 순간 바로 사라짐

---

## 3️⃣ Retain Cycle(순환 참조)란?

### 문제 상황

두 객체가 **서로를 강하게 잡고 놓지 않는 상태**

실생활 비유

* A가 B 팔 붙잡음
* B가 A 팔 붙잡음
* 둘 다 “난 아직 쓰이고 있어”라고 착각함
  → 절대 안 놓음 → 메모리 누수

---

### 코드 예시

```swift
class A {
    var b: B?
}

class B {
    var a: A?
}
```

A ↔ B 둘 다 strong이면
→ reference count가 0이 될 수 없음

---

## 4️⃣ Retain Cycle 방지 방법

### 핵심 해결책

👉 **한쪽을 weak 또는 unowned로 바꿔라**

---

### weak

* 참조는 하되
* **소유하지 않음**
* 객체 사라지면 자동으로 `nil`

```swift
class B {
    weak var a: A?
}
```

### 언제 쓰냐?

* delegate
* 부모 ↔ 자식 관계
* 언제 사라질지 모르는 참조

---

### unowned

* weak이랑 비슷
* **nil이 될 수 없음**
* 객체가 먼저 사라지면 크래시

```swift
class B {
    unowned var a: A
}
```

### 언제 쓰냐?

* 수명 주기가 명확히 같을 때

---

## 5️⃣ 클로저에서 Retain Cycle (진짜 자주 나옴)

### 문제 코드

```swift
class VC {
    func load() {
        someAsync {
            self.doSomething()
        }
    }
}
```

* 클로저가 self를 잡고
* self가 클로저를 잡고
  → 순환 참조 발생 가능

---

### 해결 코드

```swift
someAsync { [weak self] in
    self?.doSomething()
}
```

👉 클로저에서는 **무조건 한 번 의심**해야 함

---

## 6️⃣ deinit이란?

### 개념

`deinit`은 **객체가 메모리에서 제거되기 직전에 호출되는 메서드**임

### 언제 호출됨?

* reference count가 0이 되는 순간
* ARC가 객체를 해제하기 직전

---

### 역할

* 리소스 정리
* observer 제거
* notification 해제
* 타이머 invalidate

```swift
deinit {
    print("메모리에서 제거됨")
}
```

👉 deinit이 안 불린다?
→ **메모리 누수 의심해야 함**

---

## 7️⃣ 평생 안 까먹는 요약

* ARC는 **참조 개수로 메모리 관리**
* reference count = 0 → 즉시 해제
* Retain Cycle = 서로 놓지 않는 상태
* 해결 = weak / unowned
* 클로저는 Retain Cycle 주범
* deinit은 **객체 죽기 직전 호출**

---

## 마지막으로 이 문장만 기억하면 됨

> ARC는 “아직 쓰고 있냐?”만 본다
> 안 쓰면 바로 지운다
> 서로 붙잡고 있으면 절대 안 죽는다
