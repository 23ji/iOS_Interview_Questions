#  24. 자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도를 설명해주세요.

### **퀵 정렬 (Quick Sort)**

#### **동작 원리**
1. **피벗 선택**: 배열에서 하나의 요소를 선택(일반적으로 첫 번째, 마지막, 중간값 또는 랜덤)하여 기준점(`pivot`)으로 사용.
2. **분할**: 피벗을 기준으로 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치하도록 배열을 나눔.
3. **재귀 호출**: 분할된 왼쪽과 오른쪽 배열에 대해 퀵 정렬을 재귀적으로 호출.
4. **병합 없음**: 정렬은 분할 단계에서 이루어지며, 추가적인 병합 과정이 필요하지 않음.

#### **시간 복잡도**
- **평균 시간 복잡도**: \(O(n \log n)\)  
  - 분할 과정에서 배열이 균등하게 나뉘는 경우.
- **최악 시간 복잡도**: \(O(n^2)\)  
  - 분할이 비효율적으로 이루어져 하나의 배열만 계속 나뉘는 경우(예: 이미 정렬된 배열에서 첫 번째 요소를 피벗으로 선택 시).
- **최선 시간 복잡도**: \(O(n \log n)\)  
  - 항상 균등하게 나뉘는 경우.

---

### **병합 정렬 (Merge Sort)**

#### **동작 원리**
1. **분할**: 배열을 반으로 나눠 더 이상 나눌 수 없을 때까지 분할.
2. **정렬 및 병합**: 분할된 배열을 병합하면서 정렬된 상태로 합침.
3. **재귀 호출**: 각 분할된 배열에 대해 병합 정렬을 재귀적으로 호출.

#### **시간 복잡도**
- **평균 시간 복잡도**: \(O(n \log n)\)  
  - 분할 단계에서 \( \log n \)번, 병합 단계에서 각 단계마다 \(O(n)\) 수행.
- **최악 시간 복잡도**: \(O(n \log n)\)  
  - 배열의 분할이 항상 균등하게 이루어짐.
- **최선 시간 복잡도**: \(O(n \log n)\)  
  - 모든 경우에서 동일.

---

### **비교**
| 알고리즘      | 평균 시간 복잡도 | 최악 시간 복잡도 | 최선 시간 복잡도 | 공간 복잡도 |
|---------------|------------------|------------------|------------------|-------------|
| **퀵 정렬**   | \(O(n \log n)\) | \(O(n^2)\)       | \(O(n \log n)\)  | \(O(\log n)\) (재귀 호출) |
| **병합 정렬** | \(O(n \log n)\) | \(O(n \log n)\)  | \(O(n \log n)\)  | \(O(n)\) (병합에 필요한 추가 공간) |

#### **요약**
- **퀵 정렬**은 메모리 효율이 높고 평균적으로 빠르지만, 최악의 경우 성능이 떨어질 수 있음.
- **병합 정렬**은 안정적이고 최악의 경우에도 시간 복잡도가 \(O(n \log n)\)로 일정하지만, 추가 메모리 공간이 필요.
