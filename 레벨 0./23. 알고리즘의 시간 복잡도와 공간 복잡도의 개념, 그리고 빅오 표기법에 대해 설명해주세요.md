#  23. 알고리즘의 시간 복잡도와 공간 복잡도의 개념, 그리고 빅오 표기법에 대해 설명해주세요.

  ### 알고리즘의 시간 복잡도와 공간 복잡도 개념

- **시간 복잡도(Time Complexity)**: 알고리즘이 실행되는 데 걸리는 시간을 입력 크기(n)에 따라 분석한 것. 입력이 커질수록 실행 시간이 어떻게 증가하는지를 측정.
- **공간 복잡도(Space Complexity)**: 알고리즘이 실행되는 동안 사용하는 메모리 양을 입력 크기(n)에 따라 분석한 것.

둘 다 효율적인 알고리즘을 설계하고 평가하는 데 중요한 지표임.

---

### 빅오 표기법(Big-O Notation)

- **정의**: 알고리즘의 성능을 수학적으로 분석하기 위한 표기법. 입력 크기가 커질 때 성능에 가장 큰 영향을 미치는 연산을 기반으로 알고리즘의 성능을 나타냄.
- **목적**: 최악의 경우를 고려해 알고리즘이 얼마나 효율적인지 분석.

---

### O(n)과 O(log n)의 차이

#### O(n): 선형 시간 복잡도
- **정의**: 입력 크기(n)에 비례해서 실행 시간이 증가.
- **특징**:
  - 데이터가 늘어날수록 실행 시간도 선형적으로 증가.
  - 예: 배열의 모든 요소를 한 번씩 검사하는 알고리즘.
- **예제**:
  - 배열에서 특정 값을 찾기 위해 처음부터 끝까지 탐색 (Linear Search).
  ```swift
  for i in 0..<n {
      // n번 반복
      print(i)
  }
  ```
  - 입력 크기가 1,000이면 1,000번 연산.

#### O(log n): 로그 시간 복잡도
- **정의**: 입력 크기(n)가 커질수록 실행 시간이 느리게 증가. 대개 데이터가 절반씩 줄어드는 상황에서 발생.
- **특징**:
  - 매우 큰 데이터에서도 효율적으로 처리 가능.
  - 예: 이진 탐색(Binary Search).
- **예제**:
  - 정렬된 배열에서 값을 찾는 알고리즘.
  ```swift
  while low <= high {
      mid = (low + high) / 2
      if target == array[mid] {
          return mid
      } else if target < array[mid] {
          high = mid - 1
      } else {
          low = mid + 1
      }
  }
  ```
  - 입력 크기가 1,000이라면 최대 약 10번만 비교.

---

### O(n) vs O(log n) 성능 비교
| 입력 크기(n) | O(n): 선형 증가 | O(log n): 느린 증가 |
|--------------|----------------|---------------------|
| 10           | 10번 연산      | 4번 연산            |
| 1,000        | 1,000번 연산   | 10번 연산           |
| 1,000,000    | 1,000,000번 연산 | 20번 연산          |

---

### 직관적으로 이해하기
- O(n): 사람들이 줄을 서서 한 명씩 순서대로 물건을 사는 상황.
- O(log n): 물건을 사기 위해 줄을 반씩 나누고 필요한 곳에서만 작업하는 상황.

즉, O(log n)는 O(n)에 비해 훨씬 빠르고 효율적임.
