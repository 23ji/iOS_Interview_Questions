#  35. Array와 List의 차이점이 무엇인지 설명해주세요.

### **Array와 List의 차이점**  

`Array`와 `List`는 **데이터를 순서대로 저장**하는 자료구조지만, **메모리 할당 방식과 동작 원리에서 차이**가 있음.  

---

## ✅ **1. Array (배열)**
### 📌 **특징**  
- **고정된 크기**를 가지며, 선언할 때 크기가 정해짐.  
- **연속된 메모리 공간**을 차지하여 **인덱스로 빠르게 접근 가능(O(1))**.  
- 삽입/삭제 시 **비효율적(O(n))**, 새로운 요소를 추가하려면 기존 요소들을 이동해야 함.  

### 📌 **Swift의 Array**
Swift에서 `Array`는 **동적 배열(Dynamic Array)**로 구현되어 있음.  
즉, **초기 크기를 지정하지 않아도 내부적으로 크기를 조절하면서 사용 가능**함.
```swift
var numbers: [Int] = [1, 2, 3, 4, 5]  // 배열 선언
numbers.append(6)  // 배열에 요소 추가 (내부적으로 새로운 메모리 할당 후 복사)
numbers[2] = 10    // 인덱스로 빠르게 접근 가능
print(numbers)     // [1, 2, 10, 4, 5, 6]
```

✅ **장점:**  
- **인덱스를 이용한 빠른 접근 (O(1))**  
- **캐시 친화적(Cache-friendly)**: 연속된 메모리 배치로 접근 속도가 빠름  

❌ **단점:**  
- **삽입/삭제가 느림 (O(n))**: 중간에 요소를 추가/삭제하면 모든 요소를 이동해야 함.  
- **메모리 낭비 가능성**: 크기를 초과하면 새로운 메모리를 할당해야 함.  

---

## ✅ **2. List (연결 리스트, Linked List)**
### 📌 **특징**  
- 크기가 **가변적**이며, 필요할 때마다 동적으로 노드를 추가/삭제 가능.  
- **각 요소(Node)가 다음 요소를 가리키는 포인터를 가짐.**  
- 배열과 달리 **연속된 메모리 공간을 차지하지 않음.**  
- 삽입/삭제가 빠름(O(1)), 하지만 **임의 접근(indexing)이 느림(O(n))**.

### 📌 **Swift에서 List 구현 (Linked List)**
Swift에서는 `List` 타입이 기본 제공되지 않음.  
따라서, 직접 **연결 리스트(Linked List)** 를 구현해야 함.  

```swift
class Node<T> {
    var value: T
    var next: Node?
    
    init(value: T) {
        self.value = value
    }
}

class LinkedList<T> {
    var head: Node<T>?

    func append(_ value: T) {
        let newNode = Node(value: value)
        if let lastNode = head {
            while lastNode.next != nil {
                lastNode = lastNode.next!
            }
            lastNode.next = newNode
        } else {
            head = newNode
        }
    }
}
```

✅ **장점:**  
- **삽입/삭제가 빠름(O(1))**: 중간에 요소를 추가하거나 삭제해도 이동할 필요 없음.  
- **크기가 유동적**: 필요할 때마다 노드를 추가할 수 있음.  

❌ **단점:**  
- **인덱스로 접근이 느림(O(n))**: 처음부터 순차적으로 탐색해야 특정 요소에 접근 가능.  
- **추가적인 메모리 사용**: 각 노드가 `next` 포인터를 저장해야 해서 **메모리 사용량 증가**.  

---

## ✅ **Array vs List 비교 정리**
|  | **Array (배열)** | **List (연결 리스트)** |
|---|---|---|
| **메모리 구조** | 연속된 메모리 할당 | 비연속적인 노드와 포인터 |
| **크기 조정** | 크기 변경 시 새 배열 할당 필요 | 동적으로 크기 변경 가능 |
| **삽입/삭제 속도** | O(n) (중간 삽입/삭제 시 요소 이동 필요) | O(1) (노드 포인터만 변경하면 됨) |
| **검색 속도** | O(1) (인덱스 접근 가능) | O(n) (첫 노드부터 순차 탐색) |
| **메모리 효율** | 더 효율적 (추가적인 포인터 저장 불필요) | 노드마다 포인터 저장으로 메모리 사용 증가 |
| **Swift 기본 제공 여부** | ✅ `Array` 제공 | ❌ 직접 구현해야 함 |

---

## ✅ **iOS 개발에서 주로 사용하는 자료구조**
1. **배열(Array) → 가장 많이 사용됨**  
   - `Array`는 Swift에서 가장 많이 사용됨.  
   - 리스트와 다르게 인덱스로 빠르게 접근할 수 있고, 메모리 사용도 효율적.  
   - 대부분의 경우 배열을 사용하고, 성능 문제가 있을 때 리스트를 고려.  

2. **컬렉션(Collection)**  
   - `Array`, `Set`, `Dictionary` 등 기본적으로 제공되는 컬렉션을 활용.  

3. **연결 리스트(Linked List)**  
   - Swift에서 기본 제공되지 않지만, **큐(Queue)나 스택(Stack)을 직접 구현할 때 사용**할 수 있음.  

---

## ✅ **결론**
- **빠른 검색(읽기) & 인덱스 접근**이 필요하면 **배열(Array)** 사용  
- **자주 추가/삭제가 발생**하는 경우 **연결 리스트(List)** 사용  
- **Swift에서는 기본적으로 `Array`를 많이 사용**하고, 성능 이슈가 있을 때만 `Linked List`를 고려하면 됨. 🚀
